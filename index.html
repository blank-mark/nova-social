–í–æ—Ç –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π HTML-—Ñ–∞–π–ª. –ò–∑ –Ω–µ–≥–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–±—Ä–∞–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ Google, –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ ¬´–í–æ–π—Ç–∏¬ª –¥–ª—è –≤—Ö–æ–¥–∞ –ø–æ email –∏ –ø–∞—Ä–æ–ª—é. –ü—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Ç–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ username, —á—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤. –í—Ö–æ–¥ —Å —Ç–µ–º–∏ –∂–µ –¥–∞–Ω–Ω—ã–º–∏ (email + –ø–∞—Ä–æ–ª—å) –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å —Å–æ –≤—Å–µ–º–∏ —á–∞—Ç–∞–º–∏, –∏–∑–±—Ä–∞–Ω–Ω—ã–º–∏ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏.
```html
<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nova Prospect ‚Äî Chat (Telegram style, purple + light)</title>
<style>
  /* THEMES: default = dark purple, .light-theme for white */
  :root{
    --bg-main: #0f0c16;
    --bg-sidebar: #141018;
    --bg-chat: #121018;
    --accent: #7c4dff;
    --accent-2: #5e35b1;
    --muted: #9aa0c3;
    --text: #e9e6f7;
    --bubble-me: #f3e8ff;
    --bubble-other: #1f1a2b;
    --bubble-other-text: #ffffff;
    --max-width:1200px;
  }
  /* Light theme overrides */
  .light-theme {
    --bg-main: #ffffff;
    --bg-sidebar: #fafafa;
    --bg-chat: #ffffff;
    --accent: #7c4dff; /* keep accent purple */
    --accent-2: #5e35b1;
    --muted: #6b7280;
    --text: #111827;
    --bubble-me: #eef2ff;
    --bubble-other: #f5f7fb;
    --bubble-other-text: #111827;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg-main);font-family:Inter,Segoe UI,Arial,sans-serif;color:var(--text);-webkit-font-smoothing:antialiased}
  .app{max-width:var(--max-width);margin:8px auto;height:calc(100vh - 16px);display:flex;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,var(--bg-main),#0b0910);box-shadow:0 8px 40px rgba(0,0,0,0.4)}
  /* left panel (search + chats) */
  .left-panel{width:320px;background:var(--bg-chat);display:flex;flex-direction:column;border-right:1px solid rgba(255,255,255,0.03)}
  .left-top{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid rgba(255,255,255,0.02)}
  .left-logo{width:44px;height:44;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;color:white;font-weight:700}
  .left-search{padding:10px;border-bottom:1px solid rgba(255,255,255,0.02)}
  .search-input{width:100%;padding:10px;border-radius:12px;border:0;background:rgba(0,0,0,0.18);color:var(--text);outline:none}
  .chat-list{flex:1;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px}
  .chat-row{display:flex;gap:10px;align-items:center;padding:10px;border-radius:12px;cursor:pointer;position:relative}
  .chat-row:hover{background:rgba(124,77,255,0.04)}
  .chat-row.active{background:linear-gradient(90deg, rgba(124,77,255,0.06), rgba(94,53,177,0.03))}
  .avatar{width:56px;height:56;border-radius:12px;object-fit:cover}
  .chat-name{font-weight:700;color:var(--text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .chat-sub{font-size:13px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .unread-pill{background:#ff3b30;color:white;padding:4px 8px;border-radius:12px;font-size:12px}
  .fav-add-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:6px 8px;border-radius:8px;cursor:pointer;margin-left:8px}
  .fav-remove{position:absolute;right:6px;top:6px;background:rgba(0,0,0,0.25);border-radius:8px;padding:2px 6px;font-size:12px;cursor:pointer;color:#fff}
  /* Favorites bar at top of main area */
  .favorites-bar{display:flex;gap:10px;align-items:center;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,0.02);overflow:auto;background:linear-gradient(90deg, rgba(124,77,255,0.02), transparent)}
  .fav-item{display:flex;flex-direction:column;align-items:center;gap:6px;min-width:64px;position:relative;cursor:pointer}
  .fav-avatar{width:56px;height:56;border-radius:12px;object-fit:cover;border:2px solid rgba(255,255,255,0.03)}
  .fav-username{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:64px;text-align:center}
  /* Main chat area */
  .main{flex:1;display:flex;flex-direction:column;background:linear-gradient(180deg,#0b0910,#0f0c16)}
  .main-header{display:flex;align-items:center;gap:12px;padding:14px;border-bottom:1px solid rgba(255,255,255,0.02)}
  .main-avatar{width:48px;height:48;border-radius:12px;object-fit:cover;border:2px solid rgba(255,255,255,0.03)}
  .main-title{font-weight:800;color:var(--text)}
  .main-sub{font-size:13px;color:var(--muted)}
  .messages{flex:1;padding:20px;overflow:auto}
  .message-row{display:flex;margin-bottom:12px;align-items:flex-end}
  .message-row.me{justify-content:flex-end}
  .bubble{max-width:70%;padding:10px 14px;border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,0.4)}
  .bubble.me{background:linear-gradient(180deg,var(--bubble-me),#f4e9ff);color:#0b0b0b;border-bottom-right-radius:6px}
  .bubble.other{background:var(--bubble-other);color:var(--bubble-other-text);border-bottom-left-radius:6px}
  .msg-meta{font-size:12px;color:var(--muted);margin-bottom:6px}
  .msg-img{max-width:320px;border-radius:10px;display:block}
  .msg-audio{display:block;width:240px}
  .composer{padding:12px;border-top:1px solid rgba(255,255,255,0.02);display:flex;gap:8px;align-items:center;background:linear-gradient(180deg,#0f0c16,#0b0910)}
  .composer .actions{display:flex;gap:8px;align-items:center}
  .composer textarea{flex:1;min-height:46px;max-height:160px;padding:12px;border-radius:12px;border:0;background:#0b0810;color:var(--text);outline:none;resize:none}
  .icon-btn{width:44px;height:44;border-radius:10px;border:0;background:#111014;color:var(--text);display:flex;align-items:center;justify-content:center;cursor:pointer}
  .send-btn{background:linear-gradient(135deg,var(--accent),var(--accent-2));color:white;border-radius:12px;padding:10px 14px;border:0;cursor:pointer;font-weight:700}
  /* header controls */
  .header-controls { margin-left: auto; display:flex; gap:8px; align-items:center }
  .theme-toggle { padding:8px 10px; border-radius:8px; border:0; cursor:pointer; background:rgba(255,255,255,0.04); color:var(--text) }
  /* Mobile design ‚Äî —É–ª—É—á—à–µ–Ω–Ω—ã–π, –∫–∞–∫ –≤ Telegram */
  @media (max-width:900px){
    .app{flex-direction:column;height:100vh;margin:0;border-radius:0}
    .left-panel{width:100%;height:100%;order:1}
    .main{height:100%;order:2}
    /* –∫–ª–∞—Å—Å –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è –ø–∞–Ω–µ–ª–µ–π */
    .hide-on-mobile { display: none !important; }
    /* –∫–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ –≤ —à–∞–ø–∫–µ */
    #backBtn { display: inline-flex !important; margin-right: 8px; }
    /* –æ—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—Ç—å bottom-nav */
    .messages { padding-bottom: 80px; }
    /* –Ω–∏–∂–Ω—è—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è –≤—Å–µ–≥–¥–∞ –≤–∏–¥–Ω–∞ */
    .bottom-nav { display: flex !important; }
    /* —ç–∫—Ä–∞–Ω –Ω–∞—Å—Ç—Ä–æ–µ–∫ –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç bottom-nav */
    #settingsOverlay {
      bottom: 64px !important;
      height: auto !important;
      background: var(--bg-main) !important;
      z-index: 90 !important;
    }
    /* –ø—É–∑—ã—Ä—å–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ–∫—Ä—É–ø–Ω–µ–µ */
    .bubble {
      font-size: 16px;
      padding: 12px 16px;
      max-width: 85%;
    }
    .message-row { margin-bottom: 8px; }
    /* –ø–æ–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–∏–ª–∏–ø–∞–µ—Ç —Å–Ω–∏–∑—É */
    .composer { padding-bottom: 12px; }
    /* –∏—Å–ø—Ä–∞–≤–ª—è–µ–º –≤—ã—Å–æ—Ç—ã */
    .left-panel, .main { transition: none; }
    /* –∞–≤–∞—Ç–∞—Ä–∫–∏ –∏ –∏–∫–æ–Ω–∫–∏ */
    .avatar, .main-avatar { width: 52px; height: 52px; }
    .fav-avatar { width: 48px; height: 48px; }
    .icon-btn { width: 48px; height: 48px; }
  }
  /* –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–µ —ç–∫—Ä–∞–Ω—ã */
  @media (max-width:480px){
    .avatar, .main-avatar { width: 56px; height: 56px; }
    .chat-name { font-size: 18px; }
    .bubble { font-size: 16px; }
  }
  /* Light theme small overrides for inputs / backgrounds */
  .light-theme .search-input { background: #f2f4f8; color: var(--text); }
  .light-theme .composer textarea { background:#fff; color:var(--text); }
  .light-theme .left-panel, .light-theme .main { background: var(--bg-chat); }
  .light-theme .left-panel { border-right: 1px solid rgba(0,0,0,0.06); }
  /* —Å–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞ ‚Äî –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ã–µ –ø–æ–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ */
  .light-theme #authBlock input {
    background: #ffffff !important;
    color: #111827 !important;
    border: 1px solid #d1d5db !important;
  }
  /* ========== CALL UI ========== */
  .call-overlay {
    position: fixed;
    left: 0; right: 0; top: 0; bottom: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 200;
    background: rgba(0,0,0,0.5);
    pointer-events: none;
  }
  .call-card {
    background: var(--bg-chat);
    padding: 20px;
    border-radius: 12px;
    width: 360px;
    text-align: center;
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.04);
    pointer-events: auto;
  }
  .call-card h3 { margin: 6px 0 10px 0; font-size:18px; color:var(--text) }
  .call-card p { margin: 0 0 16px 0; color:var(--muted) }
  .call-actions { display:flex; gap:10px; justify-content:center; }
  .call-btn { padding:10px 14px; border-radius:10px; border:0; cursor:pointer; font-weight:700 }
  .call-accept { background: linear-gradient(135deg,var(--accent),var(--accent-2)); color:white }
  .call-decline { background: rgba(255,255,255,0.06); color:var(--text) }
  .call-hangup { background: #ff3b30; color: white; }
  .calling-indicator { display:none; align-items:center; gap:10px; color:var(--muted); font-size:13px; }
  #remoteAudio { display:none; }
</style>
</head>
<body>
<div class="app">
  <!-- left panel: search and chat list -->
  <div class="left-panel" id="leftPanel">
    <div class="left-top">
      <div class="left-logo">NP</div>
      <div style="flex:1">
        <div style="font-weight:800;color:var(--text)">Nova Prospect</div>
        <div class="small">–ë—ã—Å—Ç—Ä—ã–π –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä</div>
      </div>
      <div class="header-controls">
        <button id="themeToggle" class="theme-toggle" title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–µ–º—É">üåó</button>
      </div>
    </div>
    <div class="left-search">
      <input id="globalSearch" class="search-input" placeholder="–ü–æ–∏—Å–∫ –ø–æ username...">
    </div>
    <div class="chat-list" id="chatsList">
      <!-- chat rows -->
    </div>
    <div style="padding:12px;border-top:1px solid rgba(255,255,255,0.02);display:flex;gap:8px;align-items:center;">
      <div id="authBlock" style="flex:1"></div>
      <button id="newChatBtn" class="ghost-btn">–ù–æ–≤—ã–π</button>
    </div>
  </div>
  <!-- main chat area -->
  <div class="main" id="mainArea">
    <div class="main-header" id="mainHeader">
      <button id="backBtn" class="icon-btn" style="display:none;">‚Üê</button>
      <img id="peerAvatar" class="main-avatar" src="https://via.placeholder.com/48?text=?" alt="avatar">
      <div style="flex:1">
        <div id="peerName" class="main-title">–í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç</div>
        <div id="peerSub" class="main-sub">@username</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="searchInChat" class="icon-btn" title="–ü–æ–∏—Å–∫ –≤ —á–∞—Ç–µ">üîé</button>
        <button id="callBtn" class="icon-btn" title="–ü–æ–∑–≤–æ–Ω–∏—Ç—å">üìû</button>
        <button id="moreBtn" class="icon-btn" title="–ï—â—ë">‚ãØ</button>
      </div>
    </div>
    <!-- Favorites bar (–ø–æ—è–≤–ª—è—é—Ç—Å—è –∏–∑–±—Ä–∞–Ω–Ω—ã–µ) -->
    <div class="favorites-bar" id="favoritesBar" title="–ò–∑–±—Ä–∞–Ω–Ω—ã–µ ‚Äî –∫–ª–∏–∫ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è —á–∞—Ç–∞">
      <!-- favorites populated by JS -->
    </div>
    <div class="messages" id="messages"></div>
    <div class="composer">
      <div class="actions">
        <input id="imageInput" type="file" accept="image/*" style="display:none">
        <button id="imageBtn" class="icon-btn" title="–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ">üì∑</button>
        <button id="recordBtn" class="icon-btn" title="–ó–∞–ø–∏—Å–∞—Ç—å –≥–æ–ª–æ—Å">üéôÔ∏è</button>
      </div>
      <textarea id="messageInput" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ... (Enter ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å, Shift+Enter ‚Äî –Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞)"></textarea>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button id="sendBtn" class="send-btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      </div>
    </div>
  </div>
</div>
<!-- bottom nav for phone -->
<div id="bottomNav" class="bottom-nav" style="display:none;">
  <button id="navContacts">–ö–æ–Ω—Ç–∞–∫—Ç—ã</button>
  <button id="navCalls">–ó–≤–æ–Ω–∫–∏</button>
  <button id="navChats">–ß–∞—Ç—ã</button>
  <button id="navSettings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
</div>
<!-- CALL OVERLAY UI -->
<div id="callOverlay" class="call-overlay" aria-hidden="true">
  <div class="call-card" id="callCard">
    <h3 id="callTitle">–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫</h3>
    <p id="callSubtitle">@user</p>
    <div class="call-actions" id="callActions">
      <button id="acceptCallBtn" class="call-btn call-accept">–ü—Ä–∏–Ω—è—Ç—å</button>
      <button id="declineCallBtn" class="call-btn call-decline">–°–±—Ä–æ—Å–∏—Ç—å</button>
    </div>
    <div class="call-actions" style="margin-top:12px;">
      <button id="hangupBtn" class="call-btn call-hangup" style="display:none">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
    </div>
    <div style="margin-top:12px;">
      <div id="callingIndicator" class="calling-indicator">–ó–≤–æ–Ω—é‚Ä¶ <span id="callingTo">@user</span></div>
    </div>
  </div>
</div>
<!-- hidden remote audio element -->
<audio id="remoteAudio" autoplay></audio>
<!-- Firebase v12 modules -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-analytics.js";
  import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-auth.js";
  import {
    getFirestore, collection, doc, setDoc, addDoc, onSnapshot, query, orderBy, serverTimestamp, getDoc, getDocs, runTransaction, where, limit
  } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";
  import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-storage.js";
  // --- Firebase config ---
  const firebaseConfig = {
    apiKey: "AIzaSyC54igVqsMXIRriBZwiq1w6knBTnkfKIe4",
    authDomain: "nova-prospect-chat.firebaseapp.com",
    projectId: "nova-prospect-chat",
    storageBucket: "nova-prospect-chat.firebasestorage.app",
    messagingSenderId: "256806164650",
    appId: "1:256806164650:web:dd8faf7b8f11b68001d8d3",
    measurementId: "G-9V0Q2E2FNB"
  };
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const storage = getStorage(app);
  // --- UI refs ---
  const leftPanel = document.getElementById('leftPanel');
  const mainArea = document.getElementById('mainArea');
  const chatsList = document.getElementById('chatsList');
  const globalSearch = document.getElementById('globalSearch');
  const authBlock = document.getElementById('authBlock');
  const newChatBtn = document.getElementById('newChatBtn');
  const favoritesBar = document.getElementById('favoritesBar');
  const peerAvatar = document.getElementById('peerAvatar');
  const peerName = document.getElementById('peerName');
  const peerSub = document.getElementById('peerSub');
  const messagesEl = document.getElementById('messages');
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const imageBtn = document.getElementById('imageBtn');
  const imageInput = document.getElementById('imageInput');
  const recordBtn = document.getElementById('recordBtn');
  const bottomNav = document.getElementById('bottomNav');
  const themeToggle = document.getElementById('themeToggle');
  const backBtn = document.getElementById('backBtn');

  // --- favorites (localStorage) ---
  const FAV_KEY = 'np_favs_v1';
  function loadFavorites(){ try { return JSON.parse(localStorage.getItem(FAV_KEY) || '[]'); } catch(e){ return []; } }
  function saveFavorites(list){ localStorage.setItem(FAV_KEY, JSON.stringify(list)); }
  function isFav(username){ return loadFavorites().some(f => f.username === username); }
  function renderFavoritesBar(){
    const favs = loadFavorites();
    favoritesBar.innerHTML = '';
    if (favs.length === 0) {
      favoritesBar.innerHTML = '<div class="small" style="color:var(--muted)">–ò–∑–±—Ä–∞–Ω–Ω—ã—Ö –Ω–µ—Ç ‚Äî –¥–æ–±–∞–≤—å —á–µ—Ä–µ–∑ + –≤ –ø–æ–∏—Å–∫–µ</div>';
      return;
    }
    favs.forEach(f => {
      const el = document.createElement('div');
      el.className = 'fav-item';
      el.innerHTML = `
        <img src="${f.photoURL||'https://via.placeholder.com/56?text=?'}" class="fav-avatar">
        <div class="fav-username">@${f.username}</div>
      `;
      el.onclick = () => openDirectChat({ uid: f.uid, username: f.username, displayName: f.displayName, photoURL: f.photoURL });
      const rem = document.createElement('div');
      rem.className = 'fav-remove';
      rem.textContent = '‚úï';
      rem.onclick = (e) => { e.stopPropagation(); const newf = loadFavorites().filter(x => x.username !== f.username); saveFavorites(newf); renderFavoritesBar(); };
      el.style.position = 'relative';
      el.appendChild(rem);
      favoritesBar.appendChild(el);
    });
  }
  function addFavorite(profile){
    if (!profile || !profile.username) return;
    const favs = loadFavorites();
    if (favs.some(f => f.username === profile.username)) return;
    favs.unshift({ uid: profile.uid, username: profile.username, displayName: profile.displayName || '', photoURL: profile.photoURL || '' });
    saveFavorites(favs.slice(0, 50));
    renderFavoritesBar();
  }
  // --- notification helpers ---
  const threadMsgUnsubs = {};
  const unreadCounts = {};
  const lastSeenLocalKey = 'np_lastseen_v1';
  function getLastSeenMap(){ try { return JSON.parse(localStorage.getItem(lastSeenLocalKey)||'{}'); } catch(e){ return {}; } }
  function setLastSeen(threadId, ts){ const m=getLastSeenMap(); m[threadId]=ts; localStorage.setItem(lastSeenLocalKey, JSON.stringify(m)); unreadCounts[threadId]=0; renderThreadBadge(threadId); }
  function playNotificationSound(){
    try{
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type='sine';
      o.frequency.value=880;
      g.gain.value=0.06;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      setTimeout(()=>{ o.stop(); ctx.close(); }, 120);
    }catch(e){ /* ignore */ }
  }
  async function showDesktopNotification(title, body, icon){
    if (("Notification" in window) && Notification.permission === "granted") {
      try {
        const n = new Notification(title, { body, icon });
        n.onclick = () => window.focus();
      } catch(e){ console.warn(e); }
    }
  }
  // --- auth UI (–ë–ï–ó GOOGLE) ---
  function renderAuthUI(user) {
    authBlock.innerHTML = '';
    if (!user) {
      const wrapper = document.createElement('div');
      wrapper.innerHTML = `
        <input id="email" class="search-input" placeholder="Email" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);margin-bottom:6px">
        <input id="password" class="search-input" type="password" placeholder="–ü–∞—Ä–æ–ª—å" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);margin-bottom:6px">
        <input id="signupUsername" class="search-input" placeholder="username (–ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏)" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);margin-bottom:6px">
        <div style="display:flex;gap:8px">
          <button id="emailSignIn" class="ghost-btn" style="flex:1">–í–æ–π—Ç–∏</button>
          <button id="emailSignUp" class="ghost-btn" style="flex:1">–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</button>
        </div>
      `;
      authBlock.appendChild(wrapper);
      
      // –í—Ö–æ–¥ –ø–æ email/–ø–∞—Ä–æ–ª—å
      document.getElementById('emailSignIn').onclick = async () => {
        const email = wrapper.querySelector('#email').value.trim();
        const pass = wrapper.querySelector('#password').value;
        if (!email || !pass) return alert('–í–≤–µ–¥–∏—Ç–µ email –∏ –ø–∞—Ä–æ–ª—å');
        try {
          await signInWithEmailAndPassword(auth, email, pass);
        } catch(e){
          alert('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: ' + e.message);
        }
      };
      
      // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ username
      document.getElementById('emailSignUp').onclick = async () => {
        const email = wrapper.querySelector('#email').value.trim();
        const pass = wrapper.querySelector('#password').value;
        const desired = wrapper.querySelector('#signupUsername').value.trim().toLowerCase();
        if (!email || !pass) return alert('Email –∏ –ø–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã');
        
        // –ï—Å–ª–∏ username —É–∫–∞–∑–∞–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º –µ–≥–æ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∑–∞—Ä–∞–Ω–µ–µ
        if (desired) {
          const sanitized = sanitizeUsername(desired);
          if (!sanitized) return alert('Username –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 3-32 —Å–∏–º–≤–æ–ª–∞: –ª–∞—Ç–∏–Ω–∏—Ü–∞, —Ü–∏—Ñ—Ä—ã, _');
          const unameRef = doc(db, 'usernames', sanitized);
          const unameSnap = await getDoc(unameRef);
          if (unameSnap.exists()) {
            return alert('–≠—Ç–æ—Ç username —É–∂–µ –∑–∞–Ω—è—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π.');
          }
        }
        
        try {
          // –°–æ–∑–¥–∞—ë–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          const uc = await createUserWithEmailAndPassword(auth, email, pass);
          // –ï—Å–ª–∏ username –±—ã–ª —É–∫–∞–∑–∞–Ω, —Ä–µ–∑–µ—Ä–≤–∏—Ä—É–µ–º –µ–≥–æ
          if (desired) {
            try {
              await createUsernameForUid(desired, uc.user.uid, email.split('@')[0]);
            } catch(err){
              console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞—Ç—å username:', err);
              // –ú–æ–∂–Ω–æ —É–≤–µ–¥–æ–º–∏—Ç—å, –Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å–æ–∑–¥–∞–Ω ‚Äî –æ—Å—Ç–∞–≤–∏–º –±–µ–∑ username
              alert('–ê–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω, –Ω–æ username –∑–∞–Ω—è—Ç—å –Ω–µ —É–¥–∞–ª–æ—Å—å (–≤–æ–∑–º–æ–∂–Ω–æ, –∑–∞–Ω—è—Ç). –í—ã —Å–º–æ–∂–µ—Ç–µ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–≥–æ –ø–æ–∑–∂–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.');
            }
          }
          alert('–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!');
        } catch(e){
          alert('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ' + e.message);
        }
      };
    } else {
      const wrapper = document.createElement('div');
      wrapper.innerHTML = `
        <div style="display:flex;gap:8px;align-items:center">
          <img src="${user.photoURL||'https://via.placeholder.com/48?text=?'}" style="width:48px;height:48;border-radius:10px;object-fit:cover;border:2px solid rgba(255,255,255,0.03)">
          <div style="min-width:0">
            <div style="font-weight:700;color:var(--text);white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${user.displayName||'(–±–µ–∑ –∏–º–µ–Ω–∏)'}</div>
            <div class="small">${user.email||''}</div>
          </div>
        </div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="signOut" class="ghost-btn">–í—ã–π—Ç–∏</button>
        </div>
      `;
      authBlock.appendChild(wrapper);
      document.getElementById('signOut').onclick = async () => {
        if (unsubscribeThreadsAll) unsubscribeThreadsAll();
        if (unsubscribeThreads) unsubscribeThreads();
        await signOut(auth);
      };
    }
  }
  // --- username helpers ---
  async function createUsernameForUid(usernameRaw, uid, displayName = null) {
    const username = sanitizeUsername(usernameRaw);
    if (!username) throw '–ù–µ–≤–µ—Ä–Ω—ã–π username';
    const unameRef = doc(db, 'usernames', username);
    const profileRef = doc(db, 'profiles', uid);
    try {
      await runTransaction(db, async (tx) => {
        const unameSnap = await tx.get(unameRef);
        if (unameSnap.exists()) throw new Error('USERNAME_TAKEN');
        tx.set(unameRef, { owner: uid, createdAt: serverTimestamp() });
        tx.set(profileRef, { username, displayName: displayName || null, updatedAt: serverTimestamp() }, { merge: true });
      });
      return true;
    } catch (e) {
      if (String(e).includes('USERNAME_TAKEN')) throw '–≠—Ç–æ—Ç username —É–∂–µ –∑–∞–Ω—è—Ç';
      throw e.message || e;
    }
  }
  function sanitizeUsername(s) { if (!s) return null; const low = s.toLowerCase(); if (!/^[a-z0-9_]{3,32}$/.test(low)) return null; return low; }
  // --- threads list (recent chats) with unread handling ---
  let unsubscribeThreads = null;
  let unsubscribeThreadsAll = null;
  async function subscribeMyThreads(uid) {
    if (unsubscribeThreads) unsubscribeThreads();
    if (unsubscribeThreadsAll) unsubscribeThreadsAll();
    const q = query(collection(db, 'dmThreads'), where('participants', 'array-contains', uid), orderBy('createdAt', 'desc'));
    unsubscribeThreads = onSnapshot(q, async (snap) => {
      chatsList.innerHTML = '';
      if (snap.empty) {
        chatsList.innerHTML = '<div class="small" style="padding:12px;color:var(--muted)">–ù–µ—Ç —á–∞—Ç–æ–≤. –ù–∞–π–¥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –Ω–∞—á–Ω–∏ –¥–∏–∞–ª–æ–≥.</div>';
        return;
      }
      const perThreadUnsubs = [];
      for (const docSnap of snap.docs) {
        const data = docSnap.data();
        const threadId = docSnap.id;
        const otherUid = data.participants.find(x => x !== uid);
        const profileSnap = await getDoc(doc(db, 'profiles', otherUid));
        const profile = profileSnap.exists() ? profileSnap.data() : {};
        const lastText = data.lastMessageText || '';
        const el = document.createElement('div');
        el.className = 'chat-row';
        el.id = 'chatrow_' + threadId;
        el.innerHTML = `
          <img src="${profile.photoURL||'https://via.placeholder.com/48?text=?'}" class="avatar" style="width:56px;height:56;border-radius:12px">
          <div style="flex:1;min-width:0">
            <div class="chat-name">${profile.username||profile.displayName||otherUid}</div>
            <div class="chat-sub">${lastText || '–ù–æ–≤—ã–π —á–∞—Ç'}</div>
          </div>
          <div id="badge_${threadId}"></div>
        `;
        el.onclick = () => {
          openDirectChat({ uid: otherUid, username: profile.username, displayName: profile.displayName, photoURL: profile.photoURL });
          setLastSeen(threadId, Date.now());
        };
        chatsList.appendChild(el);
        // subscribe to last message of this thread for notifications
        const msgsCol = collection(db, 'dmThreads', threadId, 'messages');
        const qLast = query(msgsCol, orderBy('createdAt', 'desc'), limit(1));
        const unsub = onSnapshot(qLast, (msnap) => {
          msnap.forEach(mdoc => {
            const m = mdoc.data();
            if (m.senderId !== uid) {
              const lastSeenMap = getLastSeenMap();
              const lastSeen = lastSeenMap[threadId] || 0;
              const createdTs = m.createdAt && m.createdAt.toMillis ? m.createdAt.toMillis() : Date.now();
              if (createdTs > lastSeen) {
                unreadCounts[threadId] = (unreadCounts[threadId] || 0) + 1;
                renderThreadBadge(threadId);
                const title = (m.displayName || '–°–æ–æ–±—â–µ–Ω–∏–µ');
                const body = m.type === 'text' ? m.text : (m.type === 'image' ? '–§–æ—Ç–æ' : '–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ');
                playNotificationSound();
                showDesktopNotification(title, body, profile.photoURL || undefined);
              }
            }
          });
        }, (err) => console.warn('last message sub err', err));
        perThreadUnsubs.push(unsub);
      }
      unsubscribeThreadsAll = () => perThreadUnsubs.forEach(u => u && u());
    }, (err) => {
      console.warn('threads sub err', err);
    });
  }
  function renderThreadBadge(threadId){
    const badge = document.getElementById('badge_' + threadId);
    const count = unreadCounts[threadId] || 0;
    if (badge) badge.innerHTML = count ? `<div class="unread-pill">${count}</div>` : '';
  }
  // --- prefix search by username ---
  globalSearch.oninput = debounce(async (e) => {
    const q = e.target.value.trim().toLowerCase();
    chatsList.innerHTML = '<div class="small" style="padding:12px;color:var(--muted)">–ü–æ–∏—Å–∫...</div>';
    if (!q) {
      const user = auth.currentUser;
      if (user) subscribeMyThreads(user.uid);
      renderFavoritesBar();
      return;
    }
    try {
      const snap = await getDocs(query(collection(db, 'usernames'), limit(500)));
      const matches = [];
      snap.forEach(d => {
        const uname = d.id;
        if (uname.startsWith(q)) matches.push({ username: uname, owner: d.data().owner });
      });
      chatsList.innerHTML = '';
      if (matches.length === 0) {
        chatsList.innerHTML = '<div class="small" style="padding:12px;color:var(--muted)">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</div>';
        return;
      }
      for (const m of matches) {
        const owner = m.owner;
        const profSnap = await getDoc(doc(db, 'profiles', owner));
        const prof = profSnap.exists() ? profSnap.data() : {};
        const el = document.createElement('div');
        el.className = 'chat-row';
        el.innerHTML = `
          <img src="${prof.photoURL||'https://via.placeholder.com/56?text=?'}" class="avatar" style="width:56px;height:56;border-radius:12px">
          <div style="flex:1;min-width:0">
            <div class="chat-name">${prof.displayName || m.username}</div>
            <div class="chat-sub small">@${m.username}</div>
          </div>
          <div style="display:flex;align-items:center">
            <button class="fav-add-btn" data-username="${m.username}">Ôºã</button>
          </div>
        `;
        el.onclick = (ev) => { if (ev.target && ev.target.classList && ev.target.classList.contains('fav-add-btn')) return; openDirectChat({ uid: owner, username: m.username, displayName: prof.displayName, photoURL: prof.photoURL }); };
        el.querySelector('.fav-add-btn').onclick = (ev) => { ev.stopPropagation(); addFavorite({ uid: owner, username: m.username, displayName: prof.displayName, photoURL: prof.photoURL }); };
        chatsList.appendChild(el);
      }
    } catch (err) {
      console.warn(err); chatsList.innerHTML = '<div class="small" style="padding:12px;color:var(--muted)">–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞</div>';
    }
  }, 200);
  // --- DM thread helpers & messages ---
  function threadIdFor(u1, u2){ const ids=[u1,u2].sort(); return ids[0] + '_' + ids[1]; }
  let unsubscribeMessages = null;
  let currentPeer = null;
  let currentThreadId = null;
  async function ensureThreadExistsAndSubscribe(peer) {
    const user = auth.currentUser; if (!user) throw new Error('–ù–µ–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
    const tId = threadIdFor(user.uid, peer.uid);
    const threadRef = doc(db, 'dmThreads', tId);
    await runTransaction(db, async (tx) => {
      const tSnap = await tx.get(threadRef);
      if (!tSnap.exists()) tx.set(threadRef, { participants: [user.uid, peer.uid], createdAt: serverTimestamp() });
    });
    subscribeToMessages(tId);
    return tId;
  }
  function subscribeToMessages(tId) {
    if (unsubscribeMessages) unsubscribeMessages();
    const msgsCol = collection(db, 'dmThreads', tId, 'messages');
    const q = query(msgsCol, orderBy('createdAt', 'asc'));
    unsubscribeMessages = onSnapshot(q, (snapshot) => {
      messagesEl.innerHTML = '';
      snapshot.forEach(docSnap => { const m = docSnap.data(); renderMessage(m); });
      messagesEl.scrollTop = messagesEl.scrollHeight;
      unreadCounts[tId] = 0;
      renderThreadBadge(tId);
      setLastSeen(tId, Date.now());
    }, (err) => { console.warn('msgs sub err', err); });
    currentThreadId = tId;
  }
  function renderMessage(m) {
    const user = auth.currentUser;
    const row = document.createElement('div');
    row.className = 'message-row ' + (m.senderId === (user && user.uid) ? 'me' : 'other');
    const bubble = document.createElement('div');
    bubble.className = 'bubble ' + (m.senderId === (user && user.uid) ? 'me' : 'other');
    const meta = document.createElement('div'); meta.className = 'msg-meta';
    meta.textContent = (m.displayName || m.senderId) + ' ¬∑ ' + (m.createdAt ? new Date(m.createdAt.toMillis()).toLocaleTimeString() : '');
    bubble.appendChild(meta);
    if (m.type === 'image' && m.url) {
      const img = document.createElement('img'); img.src = m.url; img.className = 'msg-img'; bubble.appendChild(img);
      if (m.text) { const t = document.createElement('div'); t.textContent = m.text; bubble.appendChild(t); }
    } else if (m.type === 'audio' && m.url) {
      const audio = document.createElement('audio'); audio.controls = true; audio.src = m.url; audio.className = 'msg-audio'; bubble.appendChild(audio);
      if (m.text) { const t = document.createElement('div'); t.textContent = m.text; bubble.appendChild(t); }
    } else {
      const txt = document.createElement('div'); txt.textContent = m.text || ''; bubble.appendChild(txt);
    }
    row.appendChild(bubble);
    messagesEl.appendChild(row);
  }
  async function openDirectChat(peer) {
    currentPeer = peer;
    peerName.textContent = peer.displayName || peer.username || '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å';
    peerAvatar.src = peer.photoURL || 'https://via.placeholder.com/48?text=?';
    peerSub.textContent = '@' + (peer.username || '');
    try {
      const tId = await ensureThreadExistsAndSubscribe(peer);
      currentThreadId = tId;
      unreadCounts[tId] = 0;
      renderThreadBadge(tId);
      setLastSeen(tId, Date.now());
      // –º–æ–±–∏–ª—å–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è: —Å–∫—Ä—ã—Ç—å –ª–µ–≤—É—é –ø–∞–Ω–µ–ª—å, –ø–æ–∫–∞–∑–∞—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é
      if (window.innerWidth <= 900) {
        leftPanel.classList.add('hide-on-mobile');
        mainArea.classList.remove('hide-on-mobile');
      }
    } catch (e) { console.error(e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —á–∞—Ç: ' + (e.message || e)); }
  }
  // --- send message, image upload, audio upload ---
  async function sendTextMessage(text) {
    if (!text) return;
    const user = auth.currentUser; if (!user) return alert('–í–æ–π–¥–∏—Ç–µ');
    if (!currentPeer) return alert('–û—Ç–∫—Ä–æ–π —á–∞—Ç');
    try {
      const tId = await ensureThreadExistsAndSubscribe(currentPeer);
      const msgsCol = collection(db, 'dmThreads', tId, 'messages');
      await addDoc(msgsCol, { senderId: user.uid, displayName: user.displayName || user.email.split('@')[0], text, type: 'text', createdAt: serverTimestamp() });
      await setDoc(doc(db, 'dmThreads', tId), { lastMessageText: text, updatedAt: serverTimestamp() }, { merge: true });
    } catch (e) { console.error(e); alert('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ' + e.message); }
  }
  imageBtn.onclick = () => imageInput.click();
  imageInput.onchange = async (ev) => {
    const file = ev.target.files[0];
    if (!file) return;
    if (!currentPeer) return alert('–û—Ç–∫—Ä–æ–π —á–∞—Ç –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π —Ñ–æ—Ç–æ');
    const user = auth.currentUser; if (!user) return alert('–í–æ–π–¥–∏—Ç–µ');
    try {
      const tId = await ensureThreadExistsAndSubscribe(currentPeer);
      const path = `dmThreads/${tId}/media/${Date.now()}_${file.name}`;
      const sRef = storageRef(storage, path);
      const snap = await uploadBytes(sRef, file);
      const url = await getDownloadURL(sRef);
      const msgsCol = collection(db, 'dmThreads', tId, 'messages');
      await addDoc(msgsCol, { senderId: user.uid, displayName: user.displayName || user.email.split('@')[0], text: '', url, type: 'image', createdAt: serverTimestamp() });
      await setDoc(doc(db, 'dmThreads', tId), { lastMessageText: '[–§–æ—Ç–æ]', updatedAt: serverTimestamp() }, { merge: true });
      imageInput.value = '';
    } catch (e) { console.error(e); alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ' + (e.message || e)); }
  };
  // --- audio recording ---
  let mediaRecorder = null; let audioChunks = [];
  recordBtn.onclick = async () => {
    if (mediaRecorder && mediaRecorder.state === 'recording') { mediaRecorder.stop(); recordBtn.textContent = 'üéôÔ∏è'; recordBtn.style.background = ''; }
    else {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstop = async () => { const blob = new Blob(audioChunks, { type: 'audio/webm' }); await uploadAudioBlob(blob); };
        mediaRecorder.start();
        recordBtn.textContent = '‚ñ†'; recordBtn.style.background = '#ffdddd';
      } catch (e) { console.error(e); alert('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: ' + (e.message || e)); }
    }
  };
  async function uploadAudioBlob(blob) {
    if (!currentPeer) return alert('–û—Ç–∫—Ä–æ–π —á–∞—Ç –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ');
    const user = auth.currentUser; if (!user) return alert('–í–æ–π–¥–∏—Ç–µ');
    try {
      const tId = await ensureThreadExistsAndSubscribe(currentPeer);
      const path = `dmThreads/${tId}/media/${Date.now()}_voice.webm`;
      const sRef = storageRef(storage, path);
      await uploadBytes(sRef, blob);
      const url = await getDownloadURL(sRef);
      const msgsCol = collection(db, 'dmThreads', tId, 'messages');
      await addDoc(msgsCol, { senderId: user.uid, displayName: user.displayName || user.email.split('@')[0], text: '', url, type: 'audio', createdAt: serverTimestamp() });
      await setDoc(doc(db, 'dmThreads', tId), { lastMessageText: '[–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]', updatedAt: serverTimestamp() }, { merge: true });
    } catch (e) { console.error(e); alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≥–æ–ª–æ—Å–∞: ' + (e.message || e)); }
  }
  // --- send on Enter ---
  messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendBtn.click(); } });
  sendBtn.onclick = () => { const text = messageInput.value.trim(); if (!text) return; sendTextMessage(text); messageInput.value = ''; };
  // --- auth state handling ---
  onAuthStateChanged(auth, async (user) => {
    renderAuthUI(user);
    renderFavoritesBar();
    if (user) {
      subscribeMyThreads(user.uid);
      if ("Notification" in window && Notification.permission === "default") {
        try { await Notification.requestPermission(); } catch(e){ /* ignore */ }
      }
    } else {
      if (unsubscribeThreads) unsubscribeThreads();
      if (unsubscribeThreadsAll) unsubscribeThreadsAll();
    }
  });
  newChatBtn.onclick = () => {
    const username = prompt('–í–≤–µ–¥–∏—Ç–µ username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ª–∞—Ç–∏–Ω–∏—Ü–∞, –±–µ–∑ @):');
    if (!username) return;
    (async () => {
      try {
        const unameSnap = await getDoc(doc(db, 'usernames', username.trim().toLowerCase()));
        if (!unameSnap.exists()) return alert('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
        const owner = unameSnap.data().owner;
        const prof = (await getDoc(doc(db, 'profiles', owner))).data() || {};
        openDirectChat({ uid: owner, username: username.trim().toLowerCase(), displayName: prof.displayName, photoURL: prof.photoURL });
      } catch (e) { console.error(e); alert('–û—à–∏–±–∫–∞: ' + e.message); }
    })();
  };
  // --- theme toggle logic ---
  const THEME_KEY = 'np_theme_v1';
  function loadTheme(){ try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch(e){ return 'dark'; } }
  function saveTheme(t){ try { localStorage.setItem(THEME_KEY, t); } catch(e){} }
  function applyTheme(t){
    if (t === 'light') document.documentElement.classList.add('light-theme');
    else document.documentElement.classList.remove('light-theme');
    themeToggle.textContent = (t === 'light') ? 'üåû' : 'üåô';
  }
  (function(){ const cur = loadTheme(); applyTheme(cur); })();
  themeToggle.onclick = () => { const cur = loadTheme(); const next = cur === 'light' ? 'dark' : 'light'; applyTheme(next); saveTheme(next); };
  // --- mobile navigation ---
  function updateMobileUI(){
    if (window.innerWidth <= 900) {
      bottomNav.style.display = 'flex';
      if (!currentPeer) {
        leftPanel.classList.remove('hide-on-mobile');
        mainArea.classList.add('hide-on-mobile');
      } else {
        leftPanel.classList.add('hide-on-mobile');
        mainArea.classList.remove('hide-on-mobile');
      }
    } else {
      bottomNav.style.display = 'none';
      leftPanel.classList.remove('hide-on-mobile');
      mainArea.classList.remove('hide-on-mobile');
    }
  }
  window.addEventListener('resize', updateMobileUI);
  updateMobileUI();
  // --- back button ---
  backBtn.addEventListener('click', () => {
    if (window.innerWidth <= 900) {
      leftPanel.classList.remove('hide-on-mobile');
      mainArea.classList.add('hide-on-mobile');
      currentPeer = null; // –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
    }
  });
  // bottom nav handlers
  document.getElementById('navChats').onclick = () => {
    if (window.innerWidth <= 900) {
      leftPanel.classList.remove('hide-on-mobile');
      mainArea.classList.add('hide-on-mobile');
      currentPeer = null;
    }
  };
  document.getElementById('navContacts').onclick = () => alert('–ö–æ–Ω—Ç–∞–∫—Ç—ã ‚Äî –ø–æ–∑–∂–µ');
  document.getElementById('navCalls').onclick = () => alert('–ó–≤–æ–Ω–∫–∏ ‚Äî –ø–æ–∑–∂–µ');
  document.getElementById('navSettings').onclick = async () => {
    const settingsOverlay = document.createElement('div');
    settingsOverlay.id = 'settingsOverlay';
    settingsOverlay.style.position = 'fixed';
    settingsOverlay.style.left = '0';
    settingsOverlay.style.top = '0';
    settingsOverlay.style.width = '100%';
    settingsOverlay.style.background = 'var(--bg-main)';
    settingsOverlay.style.zIndex = '100';
    settingsOverlay.style.overflow = 'auto';
    settingsOverlay.style.padding = '20px';
    if (window.innerWidth <= 900) {
      settingsOverlay.style.bottom = '64px';
      settingsOverlay.style.height = 'auto';
    } else {
      settingsOverlay.style.height = '100%';
    }
    settingsOverlay.innerHTML = `
      <button id="closeSettings" style="margin-bottom:20px;">‚Üê –ù–∞–∑–∞–¥</button>
      <div id="settingsAuth" style="margin-bottom:20px;"></div>
      <input type="file" id="profilePhotoInput" accept="image/*" style="margin-bottom:10px; width:100%; padding:8px;">
      <button id="uploadProfilePhoto" style="width:100%; padding:12px;">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è</button>
      <input id="displayNameInput" placeholder="–ù–æ–≤–æ–µ –∏–º—è" style="margin-top:20px;margin-bottom:10px;padding:12px; width:100%;">
      <button id="updateName" style="width:100%; padding:12px;">–û–±–Ω–æ–≤–∏—Ç—å –∏–º—è</button>
    `;
    document.body.appendChild(settingsOverlay);
    const user = auth.currentUser;
    if (user) {
      const settingsAuth = document.getElementById('settingsAuth');
      settingsAuth.innerHTML = `
        <div style="display:flex;gap:8px;align-items:center">
          <img src="${user.photoURL||'https://via.placeholder.com/48?text=?'}" style="width:72px;height:72;border-radius:16px;object-fit:cover;border:2px solid rgba(255,255,255,0.03)">
          <div>
            <div style="font-weight:700;color:var(--text)">${user.displayName||'(–±–µ–∑ –∏–º–µ–Ω–∏)'}</div>
            <div class="small">${user.email||''}</div>
          </div>
        </div>
        <button id="signOutSettings" class="ghost-btn" style="margin-top:10px;">–í—ã–π—Ç–∏</button>
      `;
      document.getElementById('signOutSettings').onclick = async () => {
        await signOut(auth);
        settingsOverlay.remove();
      };
      document.getElementById('uploadProfilePhoto').onclick = async () => {
        const file = document.getElementById('profilePhotoInput').files[0];
        if (!file) return;
        try {
          const path = `profiles/${user.uid}/avatar`;
          const sRef = storageRef(storage, path);
          await uploadBytes(sRef, file);
          const url = await getDownloadURL(sRef);
          await updateProfile(user, { photoURL: url });
          await setDoc(doc(db, 'profiles', user.uid), { photoURL: url }, { merge: true });
          alert('–§–æ—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ');
          settingsOverlay.remove();
        } catch (e) { alert('–û—à–∏–±–∫–∞: ' + e.message); }
      };
      document.getElementById('updateName').onclick = async () => {
        const newName = document.getElementById('displayNameInput').value.trim();
        if (!newName) return;
        try {
          await updateProfile(user, { displayName: newName });
          await setDoc(doc(db, 'profiles', user.uid), { displayName: newName }, { merge: true });
          alert('–ò–º—è –æ–±–Ω–æ–≤–ª–µ–Ω–æ');
          settingsOverlay.remove();
        } catch (e) { alert('–û—à–∏–±–∫–∞: ' + e.message); }
      };
    } else {
      document.getElementById('settingsAuth').innerHTML = '<div>–í–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç</div>';
    }
    document.getElementById('closeSettings').onclick = () => settingsOverlay.remove();
  };
  // --- utilities ---
  function debounce(fn, ms) { let t; return (...a)=>{ clearTimeout(t); t = setTimeout(()=>fn(...a), ms); }; }
  function escapeHtml(s) { if (!s) return ''; return String(s).replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }
  renderFavoritesBar();
  window.setLastSeen = setLastSeen;
  /* ===================== */
  /* === WEBRTC CALLS === */
  /* ===================== */
  const callOverlay = document.getElementById('callOverlay');
  const callTitle = document.getElementById('callTitle');
  const callSubtitle = document.getElementById('callSubtitle');
  const acceptCallBtn = document.getElementById('acceptCallBtn');
  const declineCallBtn = document.getElementById('declineCallBtn');
  const hangupBtn = document.getElementById('hangupBtn');
  const callingIndicator = document.getElementById('callingIndicator');
  const callingTo = document.getElementById('callingTo');
  const remoteAudio = document.getElementById('remoteAudio');
  const callBtn = document.getElementById('callBtn');
  // WebRTC state
  let pc = null;
  let localStream = null;
  let currentCallDocRef = null;
  let offerCandidatesUnsub = null;
  let answerCandidatesUnsub = null;
  let incomingCallsUnsub = null;
  let currentIncomingCallId = null;
  const rtcConfig = { iceServers: [ { urls: 'stun:stun.l.google.com:19302' } ] };
  function showCallOverlay(mode, info) {
    if (mode === 'incoming') {
      callTitle.textContent = '–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫';
      callSubtitle.textContent = `@${info.callerName || info.callerUid}`;
      acceptCallBtn.style.display = '';
      declineCallBtn.style.display = '';
      hangupBtn.style.display = 'none';
      callingIndicator.style.display = 'none';
    } else if (mode === 'outgoing') {
      callTitle.textContent = '–ó–≤–æ–Ω–æ–∫';
      callSubtitle.textContent = `@${info.calleeName || info.calleeUid}`;
      acceptCallBtn.style.display = 'none';
      declineCallBtn.style.display = 'none';
      hangupBtn.style.display = '';
      callingIndicator.style.display = '';
      callingTo.textContent = '@' + (info.calleeName || info.calleeUid);
    } else if (mode === 'incall') {
      callTitle.textContent = '–í —Ä–∞–∑–≥–æ–≤–æ—Ä–µ';
      callSubtitle.textContent = `@${info.peerName || info.peerUid}`;
      acceptCallBtn.style.display = 'none';
      declineCallBtn.style.display = 'none';
      hangupBtn.style.display = '';
      callingIndicator.style.display = 'none';
    }
    callOverlay.style.display = 'flex';
    callOverlay.setAttribute('aria-hidden', 'false');
  }
  function hideCallOverlay() { callOverlay.style.display = 'none'; callOverlay.setAttribute('aria-hidden', 'true'); }
  async function cleanUpCallState(markEnded = true) {
    try {
      if (offerCandidatesUnsub) { offerCandidatesUnsub(); offerCandidatesUnsub = null; }
      if (answerCandidatesUnsub) { answerCandidatesUnsub(); answerCandidatesUnsub = null; }
    } catch (e) { console.warn('cleanup unsub err', e); }
    if (pc) {
      try { pc.getSenders().forEach(s => { try { if (s.track) s.track.stop(); } catch(e){} }); } catch(e){}
      try { pc.close(); } catch (e) {}
      pc = null;
    }
    if (localStream) {
      try { localStream.getTracks().forEach(t => t.stop()); } catch(e){}
      localStream = null;
    }
    remoteAudio.srcObject = null;
    if (currentCallDocRef && markEnded) {
      try { await setDoc(currentCallDocRef, { status: 'ended' }, { merge: true }); } catch(e){ console.warn(e); }
    }
    currentCallDocRef = null;
    currentIncomingCallId = null;
    hideCallOverlay();
  }
  async function startCallToPeer(peer) {
    const user = auth.currentUser;
    if (!user) return alert('–í–æ–π–¥–∏—Ç–µ');
    if (!peer || !peer.uid) return alert('–û—Ç–∫—Ä–æ–π —á–∞—Ç —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—á–µ—à—å –ø–æ–∑–≤–æ–Ω–∏—Ç—å');
    pc = new RTCPeerConnection(rtcConfig);
    pc.ontrack = (event) => { try { remoteAudio.srcObject = event.streams[0]; } catch(e){ console.warn(e); } };
    pc.onicecandidate = async (e) => {
      if (!e.candidate) return;
      try { await addDoc(collection(currentCallDocRef, 'offerCandidates'), e.candidate.toJSON()); } catch (err) { console.warn(err); }
    };
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    } catch (e) { console.error(e); alert('–ù—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É'); return; }
    const callDocRef = doc(collection(db, 'webrtcCalls'));
    currentCallDocRef = callDocRef;
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await setDoc(callDocRef, {
      callerUid: user.uid,
      callerName: user.displayName || (user.email ? user.email.split('@')[0] : user.uid),
      calleeUid: peer.uid,
      calleeName: peer.username || peer.displayName || peer.uid,
      offer: { type: offer.type, sdp: offer.sdp },
      status: 'ringing',
      createdAt: serverTimestamp()
    }, { merge: true });
    const unsubCall = onSnapshot(callDocRef, (snap) => {
      const data = snap.data();
      if (!data) return;
      if (data.answer && pc && !pc.remoteDescription) {
        const answerDesc = new RTCSessionDescription(data.answer);
        pc.setRemoteDescription(answerDesc).catch(e => console.warn(e));
      }
      if (data.status === 'accepted') showCallOverlay('incall', { peerName: peer.username || peer.displayName || peer.uid });
      if (data.status === 'declined' || data.status === 'ended') cleanUpCallState(false);
    }, (err) => console.warn(err));
    answerCandidatesUnsub = onSnapshot(collection(callDocRef, 'answerCandidates'), (snap) => {
      snap.docChanges().forEach(change => {
        if (change.type === 'added') { const c = change.doc.data(); try { pc.addIceCandidate(new RTCIceCandidate(c)).catch(e => console.warn(e)); } catch(e){} }
      });
    });
    showCallOverlay('outgoing', { calleeName: peer.username || peer.displayName || peer.uid });
    hangupBtn.style.display = '';
    hangupBtn.onclick = async () => {
      await setDoc(callDocRef, { status: 'ended' }, { merge: true });
      unsubCall();
      await cleanUpCallState(false);
    };
  }
  async function acceptIncomingCall(callDocId) {
    try {
      const user = auth.currentUser; if (!user) return alert('–í–æ–π–¥–∏—Ç–µ');
      const callDocRef = doc(db, 'webrtcCalls', callDocId);
      currentCallDocRef = callDocRef;
      const callSnap = await getDoc(callDocRef);
      if (!callSnap.exists()) return alert('–í—ã–∑–æ–≤ –±–æ–ª—å—à–µ –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
      const data = callSnap.data();
      pc = new RTCPeerConnection(rtcConfig);
      pc.ontrack = (event) => { try { remoteAudio.srcObject = event.streams[0]; } catch(e){} };
      pc.onicecandidate = async (e) => {
        if (!e.candidate) return;
        try { await addDoc(collection(callDocRef, 'answerCandidates'), e.candidate.toJSON()); } catch (err) { console.warn(err); }
      };
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      } catch (e) { console.error(e); alert('–ù—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É'); await setDoc(callDocRef, { status: 'declined' }, { merge: true }); return; }
      const offer = data.offer; if (!offer) return alert('–û—Ñ—Ñ–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω');
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await setDoc(callDocRef, { answer: { type: answer.type, sdp: answer.sdp }, status: 'accepted' }, { merge: true });
      offerCandidatesUnsub = onSnapshot(collection(callDocRef, 'offerCandidates'), (snap) => {
        snap.docChanges().forEach(change => {
          if (change.type === 'added') { const c = change.doc.data(); try { pc.addIceCandidate(new RTCIceCandidate(c)).catch(e => console.warn(e)); } catch(e){} }
        });
      });
      const unsubCall = onSnapshot(callDocRef, (snap) => {
        const d = snap.data(); if (!d) return;
        if (d.status === 'ended' || d.status === 'declined') { cleanUpCallState(false); unsubCall(); }
      });
      showCallOverlay('incall', { peerName: data.callerName || data.callerUid });
      hangupBtn.onclick = async () => {
        await setDoc(callDocRef, { status: 'ended' }, { merge: true });
        unsubCall(); await cleanUpCallState(false);
      };
    } catch (e) { console.error(e); alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ –∑–≤–æ–Ω–∫–∞'); }
  }
  async function declineIncomingCall(callDocId) {
    try { const callDocRef = doc(db, 'webrtcCalls', callDocId); await setDoc(callDocRef, { status: 'declined' }, { merge: true }); await cleanUpCallState(false); } catch (e) { console.warn(e); }
  }
  function subscribeIncomingCallsFor(uid) {
    if (incomingCallsUnsub) incomingCallsUnsub();
    const q = query(collection(db, 'webrtcCalls'), where('calleeUid', '==', uid));
    incomingCallsUnsub = onSnapshot(q, (snap) => {
      snap.forEach(docSnap => {
        const data = docSnap.data(); const id = docSnap.id;
        if (data && data.status === 'ringing') {
          if (currentIncomingCallId && currentIncomingCallId !== id) return;
          currentIncomingCallId = id;
          callTitle.textContent = '–í–∞–º –∑–≤–æ–Ω–∏—Ç';
          callSubtitle.textContent = '@' + (data.callerName || data.callerUid);
          acceptCallBtn.style.display = ''; declineCallBtn.style.display = ''; hangupBtn.style.display = 'none'; callingIndicator.style.display = 'none';
          callOverlay.style.display = 'flex'; callOverlay.setAttribute('aria-hidden', 'false');
          acceptCallBtn.onclick = async () => { acceptCallBtn.disabled = true; await acceptIncomingCall(id); acceptCallBtn.disabled = false; };
          declineCallBtn.onclick = async () => { declineCallBtn.disabled = true; await declineIncomingCall(id); declineCallBtn.disabled = false; };
        }
      });
    }, (err) => console.warn('incoming calls sub err', err));
  }
  callBtn.addEventListener('click', async () => {
    if (!currentPeer || !currentPeer.uid) return alert('–û—Ç–∫—Ä–æ–π —á–∞—Ç —Å —á–µ–ª–æ–≤–µ–∫–æ–º, –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—á–µ—à—å –ø–æ–∑–≤–æ–Ω–∏—Ç—å');
    try { await startCallToPeer(currentPeer); } catch (e) { console.error(e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫: ' + (e.message || e)); await cleanUpCallState(); }
  });
  hangupBtn.addEventListener('click', async () => {
    if (currentCallDocRef) { try { await setDoc(currentCallDocRef, { status: 'ended' }, { merge: true }); } catch(e){} }
    await cleanUpCallState();
  });
  onAuthStateChanged(auth, (user) => {
    if (user) subscribeIncomingCallsFor(user.uid); else { if (incomingCallsUnsub) { incomingCallsUnsub(); incomingCallsUnsub = null; } }
  });
</script>
</body>
</html>
```
