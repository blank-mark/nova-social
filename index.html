<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<title>nova-prospeCt ‚Äî simple ID messenger + calls</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{--bg:#0f0c16;--muted:#9aa0c3;--accent:#7c4dff}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:var(--bg);color:#e9e6f7}
  .wrap{max-width:720px;margin:18px auto;padding:16px}
  .card{background:linear-gradient(180deg,#0b0910,#0f0c16);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
  input,button{width:100%;padding:10px;border-radius:8px;border:0;margin-top:8px}
  #messages{height:320px;overflow:auto;border-radius:8px;padding:10px;background:#0b0810;border:1px solid rgba(255,255,255,0.03)}
  .msg.me{color:#0b0b0b;background:linear-gradient(180deg,#f3e8ff,#f4e9ff);padding:8px;border-radius:10px;margin:6px 0;max-width:75%;align-self:flex-end}
  .msg.other{color:#fff;background:#1f1a2b;padding:8px;border-radius:10px;margin:6px 0;max-width:75%}
  .row{display:flex;gap:8px;align-items:center}
  .top{display:flex;gap:12px;align-items:center;justify-content:space-between}
  .small{font-size:13px;color:var(--muted)}
  .call-overlay{position:fixed;left:0;right:0;top:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:1000}
  .call-card{background:#0f0c16;padding:18px;border-radius:10px;width:320px;text-align:center;border:1px solid rgba(255,255,255,0.04)}
  .btn-accept{background:linear-gradient(135deg,var(--accent),#5e35b1);color:white;padding:10px;border-radius:8px;border:0}
  .btn-decline{background:#222;padding:10px;border-radius:8px;border:0;color:white}
  .inline{display:inline-block;width:auto}
</style>
</head>
<body>
<div class="wrap">
  <div class="card" id="loginCard">
    <h2>nova-prospeCt</h2>
    <div class="small">–í–≤–µ–¥–∏—Ç–µ –∏–º—è ‚Äî —Å–∏—Å—Ç–µ–º–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–≤–æ–π –∫–æ—Ä–æ—Ç–∫–∏–π ID</div>
    <input id="nameInput" placeholder="–í–≤–µ–¥–∏—Ç–µ –∏–º—è">
    <button id="enterBtn">–í–æ–π—Ç–∏</button>
    <div class="small" style="margin-top:8px;color:var(--muted)">UID –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ –∫–æ—Ä–æ—Ç–∫–∏–π ID (XXXXX). –ù–∏–∫–æ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ —Ä–µ–≥–∞—Ç—å.</div>
  </div>

  <div class="card" id="chatCard" style="display:none;margin-top:14px">
    <div class="top">
      <div>
        <div class="small">–¢–≤o–π ID</div>
        <div style="font-weight:800;font-size:18px" id="myShortId">‚Äî</div>
        <div class="small" id="myNameShow"></div>
      </div>
      <div style="text-align:right">
        <div class="small">–û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç –ø–æ ID</div>
        <input id="peerShort" placeholder="ID —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ (XXXXX)" style="width:180px">
        <button id="openChatBtn" class="inline">–û—Ç–∫—Ä—ã—Ç—å</button>
      </div>
    </div>

    <div id="messages" style="display:flex;flex-direction:column;gap:6px;margin-top:12px"></div>

    <div style="margin-top:12px" class="row">
      <input id="msgInput" placeholder="–ù–∞–ø–∏—à–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ..." style="flex:1">
      <button id="sendBtn" style="width:120px">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
      <button id="callBtn" style="width:100px">üìû –ü–æ–∑–≤–æ–Ω–∏—Ç—å</button>
      <div class="small">–ö–Ω–æ–ø–∫–∞ –∑–≤–æ–Ω–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞, –∫–æ–≥–¥–∞ –æ—Ç–∫—Ä—ã—Ç —á–∞—Ç —Å ID.</div>
    </div>
  </div>
</div>

<!-- call overlay -->
<div id="callOverlay" class="call-overlay" aria-hidden="true">
  <div class="call-card" id="callCard">
    <h3 id="callTitle">–í—ã–∑–æ–≤</h3>
    <div class="small" id="callSubtitle">@XXXXX</div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
      <button id="acceptBtn" class="btn-accept">–ü—Ä–∏–Ω—è—Ç—å</button>
      <button id="declineBtn" class="btn-decline">–û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
    </div>
    <div style="margin-top:10px">
      <button id="hangupBtn" style="display:none;width:100%;padding:10px;border-radius:8px">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
    </div>
  </div>
</div>

<audio id="remoteAudio" autoplay></audio>

<script type="module">
/* ========== FIREBASE ========== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-auth.js";
import {
  getFirestore, doc, setDoc, addDoc, collection, onSnapshot, serverTimestamp, getDoc, updateDoc, query, where, limit
} from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyC54igVqsMXIRriBZwiq1w6knBTnkfKIe4",
  authDomain: "nova-prospect-chat.firebaseapp.com",
  projectId: "nova-prospect-chat",
  storageBucket: "nova-prospect-chat.firebasestorage.app",
  messagingSenderId: "256806164650",
  appId: "1:256806164650:web:dd8faf7b8f11b68001d8d3",
  measurementId: "G-9V0Q2E2FNB"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* ========== UI refs ========== */
const loginCard = document.getElementById('loginCard');
const chatCard = document.getElementById('chatCard');
const nameInput = document.getElementById('nameInput');
const enterBtn = document.getElementById('enterBtn');
const myShortIdEl = document.getElementById('myShortId');
const myNameShow = document.getElementById('myNameShow');
const peerShortIn = document.getElementById('peerShort');
const openChatBtn = document.getElementById('openChatBtn');
const messagesEl = document.getElementById('messages');
const msgInput = document.getElementById('msgInput');
const sendBtn = document.getElementById('sendBtn');
const callBtn = document.getElementById('callBtn');

const callOverlay = document.getElementById('callOverlay');
const callTitle = document.getElementById('callTitle');
const callSubtitle = document.getElementById('callSubtitle');
const acceptBtn = document.getElementById('acceptBtn');
const declineBtn = document.getElementById('declineBtn');
const hangupBtn = document.getElementById('hangupBtn');
const remoteAudio = document.getElementById('remoteAudio');

/* ========== state ========== */
let myUid = null;
let myName = null;
let myShort = null;
let currentPeerShort = null;
let currentChatId = null;

let pc = null;
let localStream = null;
let currentCallDocRef = null;
let offerCandidatesUnsub = null;
let answerCandidatesUnsub = null;
let incomingCallsUnsub = null;

/* ========== helpers ========== */
function shortId(uid){
  // produce consistent 5 chars from uid
  return uid.replace(/[^A-Z0-9]/gi,'').slice(0,5).toUpperCase();
}
function showOverlay(mode, info = {}){
  callOverlay.style.display = 'flex';
  callOverlay.setAttribute('aria-hidden','false');
  if(mode === 'incoming'){
    callTitle.textContent = '–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫';
    callSubtitle.textContent = '@' + (info.callerShort || 'XXXXX');
    acceptBtn.style.display = '';
    declineBtn.style.display = '';
    hangupBtn.style.display = 'none';
  } else if (mode === 'outgoing'){
    callTitle.textContent = '–ó–≤–æ–Ω–æ–∫';
    callSubtitle.textContent = '@' + (info.calleeShort || 'XXXXX');
    acceptBtn.style.display = 'none';
    declineBtn.style.display = 'none';
    hangupBtn.style.display = '';
  } else if (mode === 'incall') {
    callTitle.textContent = '–í —Ä–∞–∑–≥–æ–≤–æ—Ä–µ';
    callSubtitle.textContent = '@' + (info.peerShort || 'XXXXX');
    acceptBtn.style.display = 'none';
    declineBtn.style.display = 'none';
    hangupBtn.style.display = '';
  }
}
function hideOverlay(){
  callOverlay.style.display = 'none';
  callOverlay.setAttribute('aria-hidden','true');
}

/* ========== AUTH & PROFILE (anonymous) ========== */
enterBtn.onclick = async () => {
  const name = nameInput.value.trim();
  if(!name) return alert('–í–≤–µ–¥–∏ –∏–º—è');
  try{
    const res = await signInAnonymously(auth);
    myUid = res.user.uid;
    myName = name;
    myShort = shortId(myUid);
    // save profile (short id used as doc id for easy lookup)
    await setDoc(doc(db, 'users', myShort), {
      uid: myUid,
      name: myName,
      createdAt: serverTimestamp()
    });
    // UI
    myShortIdEl.textContent = myShort;
    myNameShow.textContent = myName;
    loginCard.style.display='none';
    chatCard.style.display='block';
    subscribeIncomingCallsFor(myShort);
  }catch(e){ console.error(e); alert('Auth error: ' + e.message); }
};

openChatBtn.onclick = () => {
  const peer = peerShortIn.value.trim().toUpperCase();
  if(!peer) return alert('–í–≤–µ–¥–∏ ID —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞');
  if(peer === myShort) return alert('–ù–µ–ª—å–∑—è –æ—Ç–∫—Ä—ã—Ç—å —á–∞—Ç —Å —Å–æ–±–æ–π');
  currentPeerShort = peer;
  currentChatId = [myShort, peer].sort().join('_');
  messagesEl.innerHTML = '';
  subscribeToMessages(currentChatId);
};

sendBtn.onclick = async () => {
  if(!currentChatId) return alert('–û—Ç–∫—Ä–æ–π —á–∞—Ç');
  const text = msgInput.value.trim();
  if(!text) return;
  try{
    await addDoc(collection(db, 'chats', currentChatId, 'messages'), {
      fromShort: myShort,
      fromUid: myUid,
      name: myName,
      text,
      createdAt: serverTimestamp()
    });
    msgInput.value='';
  }catch(e){ console.error(e); alert('Send error'); }
};

function subscribeToMessages(chatId){
  // unsubscribe previous if any - simplistic: just clear messages and rebind
  if(window._msgsUnsub) window._msgsUnsub(); window._msgsUnsub = null;
  const col = collection(db, 'chats', chatId, 'messages');
  window._msgsUnsub = onSnapshot(col, (snap) => {
    messagesEl.innerHTML='';
    snap.forEach(d=>{
      const m = d.data();
      const el = document.createElement('div');
      el.className = (m.fromUid === myUid) ? 'msg me' : 'msg other';
      el.textContent = (m.name ? m.name + ': ' : '') + (m.text || '[media]');
      messagesEl.appendChild(el);
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }, err => { console.warn('msgs sub err', err); });
}

/* ========== WebRTC call logic ========== */
const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

callBtn.onclick = async () => {
  if(!currentPeerShort) return alert('–û—Ç–∫—Ä–æ–π —á–∞—Ç —Å —Ç–µ–º, –∫–æ–º—É —Ö–æ—á–µ—à—å –ø–æ–∑–≤–æ–Ω–∏—Ç—å');
  await startCallToPeer(currentPeerShort);
};

async function startCallToPeer(peerShort){
  try{
    // create PeerConnection
    pc = new RTCPeerConnection(rtcConfig);
    pc.ontrack = (ev) => {
      try{ remoteAudio.srcObject = ev.streams[0]; }catch(e){console.warn(e);}
    };
    pc.onicecandidate = async (e) => {
      if(e.candidate && currentCallDocRef){
        try{ await addDoc(collection(currentCallDocRef, 'offerCandidates'), e.candidate.toJSON()); } catch(e){ console.warn(e); }
      }
    };
    // get mic
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    // create call doc
    const callRef = doc(collection(db, 'webrtcCalls'));
    currentCallDocRef = callRef;
    // offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await setDoc(callRef, {
      callerShort: myShort,
      callerUid: myUid,
      callerName: myName,
      calleeShort: peerShort,
      status: 'ringing',
      offer: { type: offer.type, sdp: offer.sdp },
      createdAt: serverTimestamp()
    });
    // listen for answer & status changes
    const unsubCallDoc = onSnapshot(callRef, docSnap => {
      const data = docSnap.data();
      if(!data) return;
      if(data.answer && pc && !pc.remoteDescription){
        pc.setRemoteDescription(new RTCSessionDescription(data.answer)).catch(e=>console.warn(e));
      }
      if(data.status === 'accepted'){
        showOverlay('incall', { peerShort });
      }
      if(data.status === 'declined' || data.status === 'ended'){
        cleanupCallState();
        unsubCallDoc();
      }
    });
    // listen for answerCandidates
    answerCandidatesUnsub = onSnapshot(collection(callRef, 'answerCandidates'), snap => {
      snap.docChanges().forEach(change=>{
        if(change.type === 'added'){
          const c = change.doc.data();
          try{ pc.addIceCandidate(new RTCIceCandidate(c)).catch(e=>console.warn(e)); } catch(e){}
        }
      });
    });
    // show outgoing UI
    showOverlay('outgoing', { calleeShort: peerShort });
    hangupBtn.style.display='';
    hangupBtn.onclick = async () => {
      if(currentCallDocRef) await updateDoc(currentCallDocRef, { status: 'ended' }).catch(()=>{});
      cleanupCallState();
      unsubCallDoc();
    };
  }catch(e){ console.error(e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫: ' + (e.message || e)); await cleanupCallState(); }
}

async function acceptIncomingCall(callId){
  try{
    const callRef = doc(db, 'webrtcCalls', callId);
    const callSnap = await getDoc(callRef);
    if(!callSnap.exists()) return alert('–í—ã–∑–æ–≤ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
    const data = callSnap.data();
    // prepare pc
    pc = new RTCPeerConnection(rtcConfig);
    pc.ontrack = (ev) => { remoteAudio.srcObject = ev.streams[0]; };
    pc.onicecandidate = async (e) => {
      if(e.candidate){
        try{ await addDoc(collection(callRef,'answerCandidates'), e.candidate.toJSON()); } catch(e){ console.warn(e); }
      }
    };
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true });
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    // set remote (offer)
    const offer = data.offer;
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    // update doc with answer + accepted status
    await updateDoc(callRef, { answer: { type: answer.type, sdp: answer.sdp }, status: 'accepted' });
    // subscribe to offerCandidates
    offerCandidatesUnsub = onSnapshot(collection(callRef, 'offerCandidates'), snap=>{
      snap.docChanges().forEach(change=>{
        if(change.type === 'added'){
          const c = change.doc.data();
          try{ pc.addIceCandidate(new RTCIceCandidate(c)).catch(e=>console.warn(e)); } catch(e){}
        }
      });
    });
    showOverlay('incall', { peerShort: data.callerShort });
    hangupBtn.style.display='';
    hangupBtn.onclick = async () => {
      await updateDoc(callRef, { status: 'ended' }).catch(()=>{});
      cleanupCallState();
    };
  }catch(e){ console.error(e); alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ –∑–≤–æ–Ω–∫–∞'); try{ await updateDoc(doc(db,'webrtcCalls',callId), { status:'declined' }); }catch{} }
}

async function declineIncomingCall(callId){
  try{ await updateDoc(doc(db,'webrtcCalls',callId), { status: 'declined' }); } catch(e){ console.warn(e); }
  hideOverlay();
}

async function cleanupCallState(markEnded=true){
  try{
    if(offerCandidatesUnsub){ offerCandidatesUnsub(); offerCandidatesUnsub=null; }
    if(answerCandidatesUnsub){ answerCandidatesUnsub(); answerCandidatesUnsub=null; }
  }catch(e){}
  if(pc){
    try{ pc.getSenders().forEach(s=>{ if(s.track) s.track.stop(); }); }catch(e){}
    try{ pc.close(); }catch(e){}
    pc = null;
  }
  if(localStream){
    try{ localStream.getTracks().forEach(t=>t.stop()); }catch(e){}
    localStream = null;
  }
  remoteAudio.srcObject = null;
  currentCallDocRef = null;
  hideOverlay();
  hangupBtn.style.display='none';
}

/* ========== incoming calls subscription ========== */
function subscribeIncomingCallsFor(short){
  if(incomingCallsUnsub) incomingCallsUnsub();
  const q = query(collection(db, 'webrtcCalls'), where('calleeShort','==', short));
  incomingCallsUnsub = onSnapshot(q, snap => {
    snap.forEach(docSnap=>{
      const data = docSnap.data(); const id = docSnap.id;
      if(!data) return;
      // show only ringing calls
      if(data.status === 'ringing'){
        // if we already in call => ignore other incoming
        if(pc) return;
        callTitle.textContent = '–í–∞–º –∑–≤–æ–Ω–∏—Ç';
        callSubtitle.textContent = '@' + (data.callerShort || 'XXXXX');
        showOverlay('incoming', { callerShort: data.callerShort });
        acceptBtn.onclick = async ()=>{
          acceptBtn.disabled = true;
          await acceptIncomingCall(id);
          acceptBtn.disabled = false;
        };
        declineBtn.onclick = async ()=>{
          declineBtn.disabled = true;
          await declineIncomingCall(id);
          declineBtn.disabled = false;
          hideOverlay();
        };
      }
    });
  }, err => console.warn('incoming sub err', err));
}

/* ========== on unload: try cleanup ========== */
window.addEventListener('beforeunload', async () => {
  try{ await cleanupCallState(false); }catch(e){}
});
</script>
</body>
</html>
